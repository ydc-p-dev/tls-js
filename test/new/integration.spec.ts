import {
  Commit,
  mapStringToRange,
  NotaryServer,
  Presentation as _Presentation,
  Prover as _Prover,
  Reveal,
  subtractRanges,
  Transcript
} from '../../src/lib';
import * as Comlink from 'comlink';
import { HTTPParser } from 'http-parser-js';


const { init, Prover, Presentation }: any = Comlink.wrap(
  // @ts-ignore
  new Worker(new URL('../worker.ts', import.meta.url)),
);

interface RuntimeConfig {
  domain: string;
  url: string;
  method: 'GET' | 'POST' | 'PUT' | 'DELETE';
  body: any;
  headers: Record<string, string>;
  cookies: string;
  notaryUrl: string;
  proxyUrl: string;
  maxSentData: number;
  maxRecvData: number;
  outputFile?: string;
  filename?: string;
}

function extractDomainFromUrl(url: string): string {
  try {
    const urlObj = new URL(url);
    return urlObj.hostname;
  } catch (err) {
    throw new Error(`Invalid URL: ${url}`);
  }
}

function getTargetDomain(): string {
  // –ú–µ—Ç–æ–¥ 1: –ó window (–≤—Å—Ç–∞–Ω–æ–≤–ª—é—î—Ç—å—Å—è wrapper)
  if (window.__TARGET_DOMAIN__) {
    console.log('‚úÖ Got TARGET_DOMAIN from window:', window.__TARGET_DOMAIN__);
    return window.__TARGET_DOMAIN__;
  }

  // –ú–µ—Ç–æ–¥ 2: –ó URL –ø–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤
  const params = new URLSearchParams(window.location.search);
  const urlDomain = params.get('domain');
  if (urlDomain) {
    console.log('‚úÖ Got TARGET_DOMAIN from URL:', urlDomain);
    return urlDomain;
  }

  throw new Error(
    '‚ùå TARGET_DOMAIN not provided.\n' +
    'window.__TARGET_DOMAIN__ = ' + (window.__TARGET_DOMAIN__ || 'undefined')
  );
}

async function getSiteConfig(): Promise<RuntimeConfig> {
  let requestData = null;
  try {
    const response = await fetch('http://localhost:3001/api/request-data');
    const responseData = await response.json();
    if (response.ok) {
      requestData = responseData;
    }
    console.log('REQUEST DATA FETCH:', requestData)
  } catch (err) {
    console.log('REQUEST DATA FETCH ERROR:', err)
  }

  const targetDomain = getTargetDomain();
  console.log('TARGET_DOMAIN:', targetDomain || 'not provided');

  const siteConfig = requestData;

  if (!siteConfig) {
    throw new Error(
      `‚ùå Configuration not found for domain: ${targetDomain}`
    );
  }

  const domain = extractDomainFromUrl(siteConfig.applyCouponUrl);
  const defaults = {
    // notaryUrl: 'http://127.0.0.1:7047',
    notaryUrl: 'http://notary-server:7047',
    proxyUrl: 'ws://127.0.0.1:55688',
    maxSentData: 4096,
    maxRecvData: 16384,
  };

  if(siteConfig === requestData) {
    console.log('requestData SELECTED')
  } else {
    console.log('NO REQUEST DATA. siteConfig SELECTED')
  }

  let method = 'POST';
  const allowedMethods = ['GET', 'POST', 'PUT', 'DELETE'];
  if (siteConfig?.method && allowedMethods.includes(siteConfig.method)) {
    method = siteConfig.method;
  }

  return {
    domain: domain,
    url: siteConfig.applyCouponUrl,
    method,
    body: requestData ? JSON.parse(siteConfig.payload) : siteConfig.payload,
    headers: siteConfig.headers || {
      'content-type': 'application/json',
    },
    cookies: siteConfig?.cookies || '',
    notaryUrl: defaults.notaryUrl!,
    proxyUrl: defaults.proxyUrl!,
    maxSentData: defaults.maxSentData!,
    maxRecvData: defaults.maxRecvData!,
    filename: siteConfig.filename,
  };
}

function withTimeout<T>(p: Promise<T>, ms: number, label = 'timeout'): Promise<T> {
  return new Promise((res, rej) => {
    const t = setTimeout(() => rej(new Error(label)), ms);
    p.then(
      v => { clearTimeout(t); res(v); },
      e => { clearTimeout(t); rej(e); }
    );
  });
}

(async function () {
  let siteConfig: RuntimeConfig;

  try {
    siteConfig = await getSiteConfig();

    console.log('SITE CONFIG', siteConfig)
  } catch (err: any) {
    console.error(err.message);
    // @ts-ignore
    const resultElement = document.getElementById('integration');
    if (resultElement) {
      resultElement.textContent = err.message;
    }
    throw err;
  }

  // –í–∏–≤–æ–¥–∏–º–æ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—é
  console.log('\nüöÄ TLSNotary Integration Test');
  console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  console.log('üéØ Domain:     ', siteConfig.domain);
  console.log('üì• Filename:   ', siteConfig.filename);
  console.log('üåê URL:        ', siteConfig.url);
  console.log('üì° Method:     ', siteConfig.method);
  console.log('üîê Notary:     ', siteConfig.notaryUrl);
  console.log('üåâ Proxy:      ', siteConfig.proxyUrl);
  console.log('üì§ Max Sent:   ', siteConfig.maxSentData, 'bytes');
  console.log('üì• Max Recv:   ', siteConfig.maxRecvData, 'bytes');

  console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  console.log('üì¶ Payload:');
  console.log(JSON.stringify(siteConfig.body, null, 2));
  console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');

  try {
    // –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è
    console.log('‚è≥ Initializing WASM...');
    await init({ loggingLevel: 'Debug' });
    console.log('‚úÖ WASM initialized');

    console.time('‚è±Ô∏è  Total time');
    console.time('üîß Setup time');

    // –°—Ç–≤–æ—Ä–µ–Ω–Ω—è Prover
    console.log('‚è≥ Creating Prover...');
    const prover = (await new Prover({
      serverDns: siteConfig.domain,
      maxRecvData: siteConfig.maxRecvData,
      maxSentData: siteConfig.maxSentData,
      network: "Bandwidth",
      timeout: 120000,
    })) as _Prover;
    console.log('‚úÖ Prover created');

    // –ü—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –¥–æ Notary
    console.log('‚è≥ Connecting to Notary Server...');
    const notary = NotaryServer.from(siteConfig.notaryUrl);
    const sessionUrl = await notary.sessionUrl();
    await prover.setup(sessionUrl);
    console.log('‚úÖ Connected to Notary');

    console.timeEnd('üîß Setup time');

    // –í—ñ–¥–ø—Ä–∞–≤–∫–∞ –∑–∞–ø–∏—Ç—É
    console.log('‚è≥ Sending request...');
    console.log('   URL:', siteConfig.url);
    console.log('   Method:', siteConfig.method);
    console.time('üåê Request time');

    const requestOptions: any = {
      url: siteConfig.url,
      method: siteConfig.method,
      headers: siteConfig.headers,
    };

    // –î–æ–¥–∞—î–º–æ body —Ç—ñ–ª—å–∫–∏ —è–∫—â–æ –Ω–µ GET
    if (siteConfig.method !== 'GET' && siteConfig.body) {
      requestOptions.body = siteConfig.body;
      console.log('   Body:', JSON.stringify(siteConfig.body).substring(0, 100) + '...');
    }

    await prover.sendRequest(siteConfig.proxyUrl, requestOptions);
    console.log('‚úÖ Request sent');
    console.timeEnd('üåê Request time');

    // –û—Ç—Ä–∏–º–∞–Ω–Ω—è transcript
    console.log('‚è≥ Getting transcript...');
    const transcript = await prover.transcript();
    const { sent, recv } = transcript;
    console.log('‚úÖ Transcript received');
    console.log('   üì§ Sent:', sent.length, 'bytes');
    console.log('   üì• Received:', recv.length, 'bytes');

    // –ü–∞—Ä—Å–∏–Ω–≥ HTTP –≤—ñ–¥–ø–æ–≤—ñ–¥—ñ
    console.log('‚è≥ Parsing response...');
    const {
      info: recvInfo,
      headers: recvHeaders,
      body: recvBody,
    } = parseHttpMessage(Buffer.from(recv), 'response');
    console.log('‚úÖ Response parsed');
    console.log('   Status:', recvInfo.trim());
    let parsedBody = null;
    // –°–ø—Ä–æ–±–∞ –ø–∞—Ä—Å–∏—Ç–∏ JSON body
    if (recvBody && recvBody[0]) {
      try {
        parsedBody = JSON.parse(recvBody[0]?.toString());
        console.log('‚úÖ JSON body parsed');
        console.log('   Response preview:', JSON.stringify(parsedBody).substring(0, 200) + '...');
      } catch (err) {
        console.log('‚ÑπÔ∏è  Response is not JSON');
        parsedBody = recvBody[0]?.toString();
        console.log('   Response preview:', parsedBody.substring(0, 200) + '...');
      }
    }


    // –°—Ç–≤–æ—Ä–µ–Ω–Ω—è commitment
    console.log('‚è≥ Creating commitment...');
    const commit: Commit = {
      sent: subtractRanges(
        { start: 0, end: sent.length },
        mapStringToRange(
          [], // –ú–æ–∂–Ω–∞ –¥–æ–¥–∞—Ç–∏ —Ä–µ—á—ñ –¥–ª—è –ø—Ä–∏—Ö–æ–≤—É–≤–∞–Ω–Ω—è
          Buffer.from(sent).toString('utf-8'),
        ),
      ),
      recv: [
        ...mapStringToRange(
          [
            recvInfo,
            // –ü–æ–∫–∞–∑—É—î–º–æ –ø–µ—Ä—à—ñ –∑–∞–≥–æ–ª–æ–≤–∫–∏
            ...recvHeaders.slice(0, Math.min(20, recvHeaders.length))
              .reduce((acc, header, i, arr) => {
                if (i % 2 === 0 && arr[i + 1]) {
                  acc.push(`${header}: ${arr[i + 1]}\r\n`);
                }
                return acc;
              }, [] as string[]),
          ],
          Buffer.from(recv).toString('utf-8'),
        ),
      ],
    };
    console.log('‚úÖ Commitment created');

    // –ù–æ—Ç–∞—Ä–∏–∑–∞—Ü—ñ—è
    console.log('‚è≥ Notarizing...');
    console.time('üîê Notarization time');
    const notarizationOutput = await prover.notarize(commit);
    console.timeEnd('üîê Notarization time');
    console.log('‚úÖ Notarization complete');

    // –°—Ç–≤–æ—Ä–µ–Ω–Ω—è Presentation
    console.log('‚è≥ Creating presentation...');
    const reveal: Reveal = {
      ...commit,
      server_identity: false,
    };

    const presentation = (await new Presentation({
      attestationHex: notarizationOutput.attestation,
      secretsHex: notarizationOutput.secrets,
      reveal: reveal,
      notaryUrl: notary.url,
      websocketProxyUrl: siteConfig.proxyUrl,
    })) as _Presentation;
    console.log('‚úÖ Presentation created');

    // –°–µ—Ä—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è
    const serialized = await presentation.serialize();
    console.log('üì¶ Serialized size:', serialized.length, 'bytes');

    // –ï–∫—Å–ø–æ—Ä—Ç JSON
    const json = await presentation.json();


    //–ì–µ–Ω–µ—Ä—É—î–º–æ —ñ–º'—è —Ñ–∞–π–ª—É
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const domainKey = process.env.TARGET_DOMAIN || siteConfig.domain;
    const fileName = `${siteConfig.filename}.json` || `proof_${domainKey}_${timestamp}.json`;

//–í—ñ–¥–ø—Ä–∞–≤–∫–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä
    await fetch('http://localhost:3001/api/save-proof', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        filename: fileName,
        data: json,
      }),
    }).then(res => res.json())
      .then(res => console.log('üíæ SERVER response:', res))
      .catch(err => console.error('‚ùå Failed to save proof on server:', err));

    console.log('üíæ Proof sent to server for saving');

    // –í–µ—Ä–∏—Ñ—ñ–∫–∞—Ü—ñ—è
    console.log('‚è≥ Verifying...');
    console.time('‚úÖ Verification time');
    const { transcript: partialTranscript, server_name } =
      await presentation.verify();
    const verifyingKey = await presentation.verifyingKey();
    console.timeEnd('‚úÖ Verification time');
    console.log('‚úÖ Verification successful');
    console.log('   Server:', server_name);
    console.log('   Verifying Key:', verifyingKey);

      // –í—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–Ω—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É
      const t = new Transcript({
        sent: partialTranscript?.sent,
        recv: partialTranscript?.recv,
      });
      const sentStr = t.sent();
      const recvStr = t.recv();

      console.log('\nüìä Results:');
      console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
      console.log('üì§ Sent:\n', sentStr.substring(0, 500), sentStr.length > 500 ? '...' : '');
      console.log('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
      console.log('üì• Received:\n', recvStr.substring(0, 500), recvStr.length > 500 ? '...' : '');
      console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');


    console.timeEnd('‚è±Ô∏è  Total time');

    // –í—ñ–¥–æ–±—Ä–∞–∑–∏—Ç–∏ –Ω–∞ —Å—Ç–æ—Ä—ñ–Ω—Ü—ñ
    // @ts-ignore
    const resultElement = document.getElementById('integration');
    if (resultElement) {
      resultElement.textContent = JSON.stringify({
        success: true,
        domain: siteConfig.domain,
        url: siteConfig.url,
        sent: sentStr,
        recv: recvStr,
        parsedResponse: parsedBody ?? null,
        version: json.version,
        meta: json.meta,
        server_name,
        verifyingKey,
        stats: {
          sentBytes: sent.length,
          recvBytes: recv.length,
          proofSize: serialized.length,
        },
      }, null, 2);
    }

    console.log('‚úÖ All done!');

  } catch (err: any) {
    console.error('\n‚ùå Error occurred:');
    console.error('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.error('Message:', err.message);
    console.error('Stack:', err.stack);
    console.error('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');

    // @ts-ignore
    const resultElement = document.getElementById('integration');
    if (resultElement) {
      resultElement.textContent = JSON.stringify({
        success: false,
        domain: siteConfig?.domain,
        url: siteConfig?.url,
        error: err.message,
        stack: err.stack,
      }, null, 2);
    }

    throw err;
  }
})();

function parseHttpMessage(buffer: Buffer, type: 'request' | 'response') {
  const parser = new HTTPParser(
    type === 'request' ? HTTPParser.REQUEST : HTTPParser.RESPONSE,
  );
  const body: Buffer[] = [];
  let complete = false;
  let headers: string[] = [];

  parser.onBody = (chunk: Buffer) => {
    body.push(chunk);
  };

  parser.onHeadersComplete = (res: any) => {
    headers = res.headers || [];
  };

  parser.onMessageComplete = () => {
    complete = true;
  };

  parser.execute(buffer);
  parser.finish();

  if (!complete) {
    throw new Error(`Could not parse ${type.toUpperCase()}`);
  }

  return {
    info: buffer.toString('utf-8').split('\r\n')[0] + '\r\n',
    headers,
    body,
  };
}